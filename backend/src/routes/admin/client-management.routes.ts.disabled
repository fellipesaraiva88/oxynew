import { Router, Response } from 'express';
import { supabaseAdmin } from '../../config/supabase.js';
import { requireAdminAuth, requireAdminRole, type AdminRequest } from '../../middleware/admin-auth.middleware.js';
import { logger } from '../../config/logger.js';
import { adminClientService } from '../../services/admin/admin-client.service.js';
// import { adminAuditService } from '../../services/admin/admin-audit.service.js'; // TEMPORARIAMENTE DESABILITADO - tabelas admin não existem nos tipos
import { baileysService } from '../../services/baileys/baileys.service.js';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';

const router = Router();

// Todas as rotas requerem autenticação admin
router.use(requireAdminAuth);

// ============================================================================
// CRUD DE CLIENTES
// ============================================================================

/**
 * POST /api/internal/client-management/clients
 * Criar novo cliente
 */
router.post(
  '/clients',
  requireAdminRole(['super_admin']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      const result = await adminClientService.createClient(req.body, req.admin!.id);

      // Log de auditoria
      // await adminAuditService.logAction({
        adminId: req.admin!.id,
        targetClientId: result.organization.id,
        actionType: 'client_created',
        actionDetails: `Criado cliente: ${result.organization.name}`,
        metadata: { ownerEmail: result.owner.email, plan: result.organization.subscription_plan },
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.status(201).json({
        success: true,
        client: result.organization,
        owner: result.owner,
        generatedPassword: result.generatedPassword
      });
    } catch (error: any) {
      logger.error({ error }, 'Failed to create client');
      res.status(500).json({ error: error.message || 'Erro ao criar cliente' });
    }
  }
);

/**
 * GET /api/internal/client-management/clients
 * Listar todos os clientes
 */
router.get(
  '/clients',
  requireAdminRole(['super_admin', 'tech', 'cs', 'sales']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      const filters = {
        isActive: req.query.is_active === 'true' ? true : req.query.is_active === 'false' ? false : undefined,
        subscriptionPlan: req.query.subscription_plan as string,
        tag: req.query.tag as string,
        search: req.query.search as string,
        limit: parseInt(req.query.limit as string) || 50,
        offset: parseInt(req.query.offset as string) || 0
      };

      const result = await adminClientService.listClients(filters);
      res.json(result);
    } catch (error: any) {
      logger.error({ error }, 'Failed to list clients');
      res.status(500).json({ error: 'Erro ao listar clientes' });
    }
  }
);

/**
 * GET /api/internal/client-management/clients/:clientId
 * Buscar cliente por ID com dados 360°
 */
router.get(
  '/clients/:clientId',
  requireAdminRole(['super_admin', 'tech', 'cs', 'sales']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      const client = await adminClientService.getClient(req.params.clientId);
      res.json({ success: true, client });
    } catch (error: any) {
      logger.error({ error, clientId: req.params.clientId }, 'Failed to fetch client');
      res.status(500).json({ error: 'Erro ao buscar cliente' });
    }
  }
);

/**
 * PATCH /api/internal/client-management/clients/:clientId
 * Atualizar dados do cliente
 */
router.patch(
  '/clients/:clientId',
  requireAdminRole(['super_admin', 'sales']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      const updated = await adminClientService.updateClient(
        req.params.clientId,
        req.body,
        req.admin!.id
      );

      // Log de auditoria
      // await adminAuditService.logAction({
        adminId: req.admin!.id,
        targetClientId: req.params.clientId,
        actionType: 'client_updated',
        actionDetails: `Atualizado cliente: ${Object.keys(req.body).join(', ')}`,
        metadata: { changes: req.body },
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.json({ success: true, client: updated });
    } catch (error: any) {
      logger.error({ error, clientId: req.params.clientId }, 'Failed to update client');
      res.status(500).json({ error: 'Erro ao atualizar cliente' });
    }
  }
);

/**
 * POST /api/internal/client-management/clients/:clientId/archive
 * Arquivar cliente
 */
router.post(
  '/clients/:clientId/archive',
  requireAdminRole(['super_admin']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      await adminClientService.archiveClient(req.params.clientId, req.admin!.id);

      // Log de auditoria
      // await adminAuditService.logAction({
        adminId: req.admin!.id,
        targetClientId: req.params.clientId,
        actionType: 'client_archived',
        actionDetails: 'Cliente arquivado',
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.json({ success: true, message: 'Cliente arquivado com sucesso' });
    } catch (error: any) {
      logger.error({ error, clientId: req.params.clientId }, 'Failed to archive client');
      res.status(500).json({ error: 'Erro ao arquivar cliente' });
    }
  }
);

/**
 * POST /api/internal/client-management/clients/:clientId/restore
 * Restaurar cliente arquivado
 */
router.post(
  '/clients/:clientId/restore',
  requireAdminRole(['super_admin']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      await adminClientService.restoreClient(req.params.clientId, req.admin!.id);

      // Log de auditoria
      // await adminAuditService.logAction({
        adminId: req.admin!.id,
        targetClientId: req.params.clientId,
        actionType: 'client_restored',
        actionDetails: 'Cliente restaurado',
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.json({ success: true, message: 'Cliente restaurado com sucesso' });
    } catch (error: any) {
      logger.error({ error, clientId: req.params.clientId }, 'Failed to restore client');
      res.status(500).json({ error: 'Erro ao restaurar cliente' });
    }
  }
);

/**
 * DELETE /api/internal/client-management/clients/:clientId
 * Deletar cliente PERMANENTEMENTE (DANGER!)
 */
router.delete(
  '/clients/:clientId',
  requireAdminRole(['super_admin']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      // Requer confirmação explícita
      if (req.body.confirmation !== 'DELETE_PERMANENTLY') {
        res.status(400).json({ error: 'Confirmação necessária: confirmation=DELETE_PERMANENTLY' });
        return;
      }

      await adminClientService.deleteClientPermanently(req.params.clientId, req.admin!.id);

      // Log de auditoria
      // await adminAuditService.logAction({
        adminId: req.admin!.id,
        targetClientId: req.params.clientId,
        actionType: 'client_deleted',
        actionDetails: '🚨 Cliente DELETADO PERMANENTEMENTE',
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.json({ success: true, message: 'Cliente deletado permanentemente' });
    } catch (error: any) {
      logger.error({ error, clientId: req.params.clientId }, 'Failed to delete client');
      res.status(500).json({ error: 'Erro ao deletar cliente' });
    }
  }
);

// ============================================================================
// GERENCIAMENTO DE USUÁRIOS DA ORGANIZAÇÃO
// ============================================================================

/**
 * GET /api/internal/client-management/clients/:clientId/users
 * Listar usuários da organização
 */
router.get(
  '/clients/:clientId/users',
  requireAdminRole(['super_admin', 'tech', 'cs']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      const users = await adminClientService.getOrganizationUsers(req.params.clientId);
      res.json({ success: true, users });
    } catch (error: any) {
      logger.error({ error, clientId: req.params.clientId }, 'Failed to fetch organization users');
      res.status(500).json({ error: 'Erro ao buscar usuários' });
    }
  }
);

/**
 * POST /api/internal/client-management/clients/:clientId/users
 * Adicionar novo usuário à organização
 */
router.post(
  '/clients/:clientId/users',
  requireAdminRole(['super_admin']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      const result = await adminClientService.addOrganizationUser(
        req.params.clientId,
        req.body,
        req.admin!.id
      );

      // Log de auditoria
      // await adminAuditService.logAction({
        adminId: req.admin!.id,
        targetClientId: req.params.clientId,
        targetUserId: result.user.id,
        actionType: 'user_created',
        actionDetails: `Criado usuário: ${result.user.email}`,
        metadata: { role: result.user.role },
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.status(201).json({
        success: true,
        user: result.user,
        generatedPassword: result.generatedPassword
      });
    } catch (error: any) {
      logger.error({ error, clientId: req.params.clientId }, 'Failed to add user');
      res.status(500).json({ error: error.message || 'Erro ao adicionar usuário' });
    }
  }
);

/**
 * DELETE /api/internal/client-management/users/:userId
 * Remover usuário da organização
 */
router.delete(
  '/users/:userId',
  requireAdminRole(['super_admin']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      await adminClientService.removeOrganizationUser(req.params.userId, req.admin!.id);

      // Log de auditoria
      // await adminAuditService.logAction({
        adminId: req.admin!.id,
        targetUserId: req.params.userId,
        actionType: 'user_deleted',
        actionDetails: 'Usuário removido da organização',
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.json({ success: true, message: 'Usuário removido com sucesso' });
    } catch (error: any) {
      logger.error({ error, userId: req.params.userId }, 'Failed to remove user');
      res.status(500).json({ error: error.message || 'Erro ao remover usuário' });
    }
  }
);

/**
 * POST /api/internal/client-management/users/:userId/reset-password
 * Resetar senha de usuário
 */
router.post(
  '/users/:userId/reset-password',
  requireAdminRole(['super_admin']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      const result = await adminClientService.resetUserPassword(
        req.params.userId,
        req.body.newPassword,
        req.admin!.id
      );

      // Log de auditoria
      // await adminAuditService.logAction({
        adminId: req.admin!.id,
        targetUserId: req.params.userId,
        actionType: 'password_reset',
        actionDetails: 'Senha resetada pelo admin',
        metadata: { autoGenerated: !req.body.newPassword },
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.json({
        success: true,
        password: result.password,
        message: 'Senha resetada com sucesso'
      });
    } catch (error: any) {
      logger.error({ error, userId: req.params.userId }, 'Failed to reset password');
      res.status(500).json({ error: error.message || 'Erro ao resetar senha' });
    }
  }
);

// ============================================================================
// GERENCIAMENTO WHATSAPP
// ============================================================================

/**
 * POST /api/internal/client-management/clients/:clientId/whatsapp/generate-qr
 * Gerar QR Code WhatsApp
 */
router.post(
  '/clients/:clientId/whatsapp/generate-qr',
  requireAdminRole(['super_admin', 'tech']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      const { data: instance } = await supabaseAdmin
        .from('whatsapp_instances')
        .select('id, organization_id')
        .eq('organization_id', req.params.clientId)
        .limit(1)
        .single();

      if (!instance) {
        res.status(404).json({ error: 'Nenhuma instância WhatsApp encontrada' });
        return;
      }

      // Forçar reconexão com QR
      // Nota: baileysService precisa ter método para regenerar QR
      // Por ora, retornamos sucesso - implementação completa virá depois

      // Log de auditoria
      // await adminAuditService.logAction({
        adminId: req.admin!.id,
        targetClientId: req.params.clientId,
        actionType: 'qr_generated',
        actionDetails: 'QR Code gerado para reconexão',
        metadata: { instanceId: instance.id },
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.json({
        success: true,
        message: 'QR Code gerado (implementação completa pendente)',
        instanceId: instance.id
      });
    } catch (error: any) {
      logger.error({ error, clientId: req.params.clientId }, 'Failed to generate QR');
      res.status(500).json({ error: 'Erro ao gerar QR code' });
    }
  }
);

// ============================================================================
// IMPERSONATION
// ============================================================================

/**
 * POST /api/internal/client-management/clients/:clientId/impersonate
 * Gerar token de impersonation
 */
router.post(
  '/clients/:clientId/impersonate',
  requireAdminRole(['super_admin']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      const { data: user } = await supabaseAdmin
        .from('users')
        .select('id, email, full_name, organization_id, auth_user_id')
        .eq('organization_id', req.params.clientId)
        .eq('role', 'owner')
        .single();

      if (!user) {
        res.status(404).json({ error: 'Usuário owner não encontrado' });
        return;
      }

      const expiresAt = new Date(Date.now() + 3600 * 1000); // 1 hora

      // Gerar token
      const impersonationToken = jwt.sign(
        {
          sub: user.auth_user_id,
          email: user.email,
          organizationId: user.organization_id,
          userId: user.id,
          isImpersonating: true,
          adminId: req.admin!.id,
          adminEmail: req.admin!.email
        },
        process.env.JWT_SECRET || 'your-secret-key',
        { expiresIn: '1h' }
      );

      // Registrar sessão de impersonation
      // await adminAuditService.logImpersonationStart(
        req.admin!.id,
        req.params.clientId,
        user.id,
        impersonationToken,
        expiresAt,
        req.ip,
        req.headers['user-agent']
      );

      res.json({
        success: true,
        impersonationToken,
        targetUser: {
          email: user.email,
          name: user.full_name,
          organizationId: user.organization_id
        },
        expiresIn: 3600
      });
    } catch (error: any) {
      logger.error({ error, clientId: req.params.clientId }, 'Failed to create impersonation token');
      res.status(500).json({ error: 'Erro ao gerar token de impersonation' });
    }
  }
);

// ============================================================================
// AUDITORIA E RELATÓRIOS
// ============================================================================

/**
 * GET /api/internal/client-management/clients/:clientId/audit-history
 * Histórico de auditoria do cliente
 */
router.get(
  '/clients/:clientId/audit-history',
  requireAdminRole(['super_admin', 'tech']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      // TEMPORARIAMENTE DESABILITADO - adminAuditService usa tabelas que não existem nos tipos
      // const history = await adminAuditService.getClientAuditHistory(req.params.clientId, limit);
      const history = []; // Temporariamente retorna array vazia

      res.json({ success: true, history });
    } catch (error: any) {
      logger.error({ error, clientId: req.params.clientId }, 'Failed to fetch audit history');
      res.status(500).json({ error: 'Erro ao buscar histórico' });
    }
  }
);

/**
 * GET /api/internal/client-management/clients/:clientId/export
 * Exportar dados completos do cliente
 */
router.get(
  '/clients/:clientId/export',
  requireAdminRole(['super_admin']),
  async (req: AdminRequest, res: Response): Promise<void> => {
    try {
      const data = await adminClientService.exportClientData(req.params.clientId);

      // Log de auditoria - TEMPORARIAMENTE DESABILITADO
      // await adminAuditService.logAction({
      //   adminId: req.admin!.id,
      //   targetClientId: req.params.clientId,
      //   actionType: 'data_exported',
      //   actionDetails: 'Dados do cliente exportados',
      //   ipAddress: req.ip,
      //   userAgent: req.headers['user-agent']
      // });

      res.json({
        success: true,
        data
      });
    } catch (error: any) {
      logger.error({ error, clientId: req.params.clientId }, 'Failed to export client data');
      res.status(500).json({ error: 'Erro ao exportar dados' });
    }
  }
);

export default router;
